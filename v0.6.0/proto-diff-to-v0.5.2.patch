5a6,8
> 
> option go_package = "github.com/lightningnetwork/lnd/lnrpc";
> 
145c148
<     invdividual branch of the BIP44 derivation paths. Supplying a recovery
---
>     individual branch of the BIP44 derivation paths. Supplying a recovery
149a153,162
> 
>     /**
>     channel_backups is an optional argument that allows clients to recover the
>     settled funds within a set of channels. This should be populated if the
>     user was unable to close out all channels and sweep funds before partial or
>     total data loss occurred. If specified, then after on-chain recovery of
>     funds, lnd begin to carry out the data loss recovery protocol in order to
>     recover the funds in each channel from a remote force closed transaction.
>     */
>     ChanBackupSnapshot channel_backups = 5;
169a183,192
> 
>     /**
>     channel_backups is an optional argument that allows clients to recover the
>     settled funds within a set of channels. This should be populated if the
>     user was unable to close out all channels and sweep funds before partial or
>     total data loss occurred. If specified, then after on-chain recovery of
>     funds, lnd begin to carry out the data loss recovery protocol in order to
>     recover the funds in each channel from a remote force closed transaction.
>     */
>     ChanBackupSnapshot channel_backups = 3;
219a243,252
>     /** lncli: `estimatefee`
>     EstimateFee asks the chain backend to estimate the fee rate and total fees
>     for a transaction that pays to multiple specified outputs.
>     */
>     rpc EstimateFee (EstimateFeeRequest) returns (EstimateFeeResponse) {
>         option (google.api.http) = {
>             get: "/v1/transactions/fee"
>         };
>     }
> 
233a267,276
>     /** lncli: `listunspent`
>     ListUnspent returns a list of all utxos spendable by the wallet with a
> 	number of confirmations between the specified minimum and maximum.
>     */
>     rpc ListUnspent (ListUnspentRequest) returns (ListUnspentResponse) {
>         option (google.api.http) = {
>             get: "/v1/utxos"
>         };
>     }
> 
263c306,311
<     rpc SignMessage (SignMessageRequest) returns (SignMessageResponse);
---
>     rpc SignMessage (SignMessageRequest) returns (SignMessageResponse) {
>         option (google.api.http) = {
>             post: "/v1/signmessage"
>             body: "*"
>         };
>     }
271c319,324
<     rpc VerifyMessage (VerifyMessageRequest) returns (VerifyMessageResponse);
---
>     rpc VerifyMessage (VerifyMessageRequest) returns (VerifyMessageResponse) {
>         option (google.api.http) = {
>             post: "/v1/verifymessage"
>             body: "*"
>         };
>     }
338a392,399
>     /** lncli: `subscribechannelevents`
>     SubscribeChannelEvents creates a uni-directional stream from the server to
>     the client in which any updates relevant to the state of the channels are
>     sent over. Events include new active channels, inactive channels, and closed
>     channels.
>     */
>     rpc SubscribeChannelEvents (ChannelEventSubscription) returns (stream ChannelEventUpdate);
> 
458,461c519,520
<     next request. The reversed flag is set by default in order to paginate
<     backwards. If you wish to paginate forwards, you must explicitly set the
<     flag to false. If none of the parameters are specified, then the last 100
<     invoices will be returned.
---
>     next request. By default, the first 100 invoices created will be returned.
>     Backwards pagination is also supported through the Reversed flag.
632c691
<     all HTLC's forwarded within the target time range, and integer offset
---
>     all HTLCs forwarded within the target time range, and integer offset
647a707,790
> 
>     /** lncli: `exportchanbackup`
>     ExportChannelBackup attempts to return an encrypted static channel backup
>     for the target channel identified by it channel point. The backup is
>     encrypted with a key generated from the aezeed seed of the user. The
>     returned backup can either be restored using the RestoreChannelBackup
>     method once lnd is running, or via the InitWallet and UnlockWallet methods
>     from the WalletUnlocker service.
>     */
>     rpc ExportChannelBackup(ExportChannelBackupRequest) returns (ChannelBackup) {
>         option (google.api.http) = {
>             get: "/v1/channels/backup/{chan_point.funding_txid_str}/{chan_point.output_index}"
>         };
>     };
> 
>     /**
>     ExportAllChannelBackups returns static channel backups for all existing
>     channels known to lnd. A set of regular singular static channel backups for
>     each channel are returned. Additionally, a multi-channel backup is returned
>     as well, which contains a single encrypted blob containing the backups of
>     each channel.
>     */
>     rpc ExportAllChannelBackups(ChanBackupExportRequest) returns (ChanBackupSnapshot) {
>         option (google.api.http) = {
>             get: "/v1/channels/backup"
>         };
>     };
> 
>     /**
>     VerifyChanBackup allows a caller to verify the integrity of a channel backup
>     snapshot. This method will accept either a packed Single or a packed Multi.
>     Specifying both will result in an error.
>     */
>     rpc VerifyChanBackup(ChanBackupSnapshot) returns (VerifyChanBackupResponse) {
>         option (google.api.http) = {
>             post: "/v1/channels/backup/verify"
>             body: "*"
>         };
>     };
> 
>     /** lncli: `restorechanbackup`
>     RestoreChannelBackups accepts a set of singular channel backups, or a
>     single encrypted multi-chan backup and attempts to recover any funds
>     remaining within the channel. If we are able to unpack the backup, then the
>     new channel will be shown under listchannels, as well as pending channels.
>     */
>     rpc RestoreChannelBackups(RestoreChanBackupRequest) returns (RestoreBackupResponse)  {
>         option (google.api.http) = {
>             post: "/v1/channels/backup/restore"
>             body: "*"
>         };
>     };
> 
>     /**
>     SubscribeChannelBackups allows a client to sub-subscribe to the most up to
>     date information concerning the state of all channel backups. Each time a
>     new channel is added, we return the new set of channels, along with a
>     multi-chan backup containing the backup info for all channels. Each time a
>     channel is closed, we send a new update, which contains new new chan back
>     ups, but the updated set of encrypted multi-chan backups with the closed
>     channel(s) removed.
>     */
>     rpc SubscribeChannelBackups(ChannelBackupSubscription) returns (stream ChanBackupSnapshot) {
>     };
> }
> 
> message Utxo {
>     /// The type of address
>     AddressType type = 1 [json_name = "address_type"];
> 
>     /// The address
>     string address = 2 [json_name = "address"];
> 
>     /// The value of the unspent coin in satoshis
>     int64 amount_sat = 3 [json_name = "amount_sat"];
> 
>     /// The pkscript in hex
>     string pk_script = 4 [json_name = "pk_script"];
> 
>     /// The outpoint in format txid:n
>     OutPoint outpoint = 5 [json_name = "outpoint"];
> 
>     /// The number of confirmations for the Utxo
>     int64 confirmations = 6 [json_name = "confirmations"];
727a871,882
> 
>     /**
>     The channel id of the channel that must be taken to the first hop. If zero,
>     any channel may be used.
>     */
>     uint64 outgoing_chan_id = 9;
> 
>     /** 
>     An optional maximum total time lock for the route. If zero, there is no
>     maximum enforced.
>     */
>     uint32 cltv_limit = 10;
728a884
> 
732a889
>     bytes payment_hash = 4 [json_name = "payment_hash"];
742,743c899,908
<     /// The set of routes that should be used to attempt to complete the payment.
<     repeated Route routes = 3;
---
>     /**
>     Deprecated. The set of routes that should be used to attempt to complete the
>     payment. The possibility to pass in multiple routes is deprecated and 
>     instead the single route field below should be used in combination with the 
>     streaming variant of SendToRoute.
>     */
>     repeated Route routes = 3 [deprecated = true];
> 
>     /// Route that should be used to attempt to complete the payment.
>     Route route = 4;
758a924,934
> message OutPoint {
>     /// Raw bytes representing the transaction id.
>     bytes txid_bytes = 1 [json_name = "txid_bytes"];
> 
>     /// Reversed, hex-encoded string representing the transaction id.
>     string txid_str = 2 [json_name = "txid_str"];
> 
>     /// The index of the output on the transaction.
>     uint32 output_index = 3 [json_name = "output_index"];
> }
> 
766a943,958
> message EstimateFeeRequest {
>     /// The map from addresses to amounts for the transaction.
>     map<string, int64> AddrToAmount = 1;
> 
>     /// The target number of blocks that this transaction should be confirmed by.
>     int32 target_conf = 2;
> }
> 
> message EstimateFeeResponse {
>     /// The total fee in satoshis.
>     int64 fee_sat = 1 [json_name = "fee_sat"];
> 
>     /// The fee rate in satoshi/byte.
>     int64 feerate_sat_per_byte = 2 [json_name = "feerate_sat_per_byte"];
> }
> 
793a986,992
> 
>     /**
>     If set, then the amount field will be ignored, and lnd will attempt to
>     send all the coins under control of the internal wallet to the specified
>     address.
>     */
>     bool send_all = 6; 
799a999,1010
> message ListUnspentRequest {
>     /// The minimum number of confirmations to be included.
>     int32 min_confs = 1;
> 
>     /// The maximum number of confirmations to be included.
>     int32 max_confs = 2;
> }
> message ListUnspentResponse {
>     /// A list of utxos
>     repeated Utxo utxos = 1 [json_name = "utxos"];
> }
> 
806,807c1017
< message NewAddressRequest {
<     enum AddressType {
---
> enum AddressType {
810c1020,1022
<     }
---
>         UNUSED_WITNESS_PUBKEY_HASH = 2;
>         UNUSED_NESTED_PUBKEY_HASH = 3;
> }
811a1024
> message NewAddressRequest {
941,943c1154,1155
<     The CSV delay expressed in relative blocks. If the channel is force
<     closed, we'll need to wait for this many blocks before we can regain our
<     funds.
---
>     The CSV delay expressed in relative blocks. If the channel is force closed,
>     we will need to wait for this many blocks before we can regain our funds.
947c1159
<     /// Whether this channel is advertised to the network or not
---
>     /// Whether this channel is advertised to the network or not.
948a1161,1166
> 
>     /// True if we were the ones that created the channel.
>     bool initiator = 18 [json_name = "initiator"];
> 
>     /// A set of flags showing the current state of the cahnnel.
>     string chan_status_flags = 19 [json_name = "chan_status_flags"];
1040a1259,1278
> 
>     enum SyncType {
>         /**
>         Denotes that we cannot determine the peer's current sync type.
>         */
>         UNKNOWN_SYNC = 0;
> 
>         /**
>         Denotes that we are actively receiving new graph updates from the peer.
>         */
>         ACTIVE_SYNC = 1;
> 
>         /**
>         Denotes that we are not receiving new graph updates from the peer.
>         */
>         PASSIVE_SYNC = 2;
>     }
> 
>     // The type of sync we are currently performing with this peer.
>     SyncType sync_type = 10 [json_name = "sync_type"];
1078,1079c1316,1320
<     /// Whether the current node is connected to testnet
<     bool testnet = 10 [json_name = "testnet"];
---
>     /** 
>     Whether the current node is connected to testnet. This field is 
>     deprecated and the network field should be used instead 
>     **/
>     bool testnet = 10 [json_name = "testnet", deprecated = true];
1081,1082c1322
<     /// A list of active chains the node is connected to
<     repeated string chains = 11 [json_name = "chains"];
---
>     reserved 11;
1094a1335,1345
> 
>     /// A list of active chains the node is connected to
>     repeated Chain chains = 16 [json_name = "chains"];
> }
> 
> message Chain {
>     /// The blockchain the node is on (eg bitcoin, litecoin)
>     string chain = 1 [json_name = "chain"];
> 
>     /// The network the node is on (eg regtest, testnet, mainnet)
>     string network = 2 [json_name = "network"];
1135d1385
<         ConfirmationUpdate confirmation = 2 [json_name = "confirmation"];
1182d1431
<         ConfirmationUpdate confirmation = 2 [json_name = "confirmation"];
1308a1558,1578
> message ChannelEventSubscription {
> }
> 
> message ChannelEventUpdate {
>     oneof channel {
>         Channel open_channel = 1 [ json_name = "open_channel" ];
>         ChannelCloseSummary closed_channel = 2 [ json_name = "closed_channel" ];
>         ChannelPoint active_channel = 3 [ json_name = "active_channel" ];
>         ChannelPoint inactive_channel = 4 [ json_name = "inactive_channel" ];
>     }
> 
>     enum UpdateType {
>          OPEN_CHANNEL = 0;
>          CLOSED_CHANNEL = 1;
>          ACTIVE_CHANNEL = 2;
>          INACTIVE_CHANNEL = 3;
>     }
> 
>     UpdateType type = 5 [ json_name = "type" ];
> }
> 
1339,1340c1609,1613
<     /// The max number of routes to return.
<     int32 num_routes = 3;
---
>     /**
>     Deprecated. The max number of routes to return. In the future, QueryRoutes
>     will only return a single route.
>     */
>     int32 num_routes = 3 [deprecated = true]; 
1351a1625,1640
> 
>     /**
>     A list of nodes to ignore during path finding.
>     */
>     repeated bytes ignored_nodes = 6;
> 
>     /**
>     A list of edges to ignore during path finding.
>     */
>     repeated EdgeLocator ignored_edges = 7;
> 
>     /**
>     The source node where the request route should originated from. If empty,
>     self is assumed.
>     */
>     string source_pub_key = 8;
1352a1642,1655
> 
> message EdgeLocator {
>     /// The short channel id of this edge.
>     uint64 channel_id = 1;
> 
>     /**
>     The direction of this edge. If direction_reverse is false, the direction
>     of this edge is from the channel endpoint with the lexicographically smaller
>     pub key to the endpoint with the larger pub key. If direction_reverse is
>     is true, the edge goes the other way.
>     */
>     bool direction_reverse = 2;
> }
> 
1470a1774
>     uint64 max_htlc_msat = 6 [json_name = "max_htlc_msat"];
1542a1847
>     int64 median_channel_size_sat = 10 [json_name = "median_channel_size_sat"];
1629,1630c1934,1937
<     /// An optional cryptographic receipt of payment
<     bytes receipt = 2 [json_name = "receipt"];
---
>     /** Deprecated. An optional cryptographic receipt of payment which is not
>     implemented.
>     */
>     bytes receipt = 2 [json_name = "receipt", deprecated = true];
1645c1952
<     bool settled = 6 [json_name = "settled"];
---
>     bool settled = 6 [json_name = "settled", deprecated = true];
1722a2030,2041
> 
>     enum InvoiceState {
>         OPEN = 0;
>         SETTLED = 1;
>         CANCELED = 2;
>         ACCEPTED = 3;
>     }
> 
>     /**
>     The state the invoice is in.
>     */
>     InvoiceState state = 21 [json_name = "state"];
1723a2043
> 
1956c2276
<     /// The total amount of the incoming HTLC that created half the circuit.
---
>     /// The total amount (in satoshis) of the incoming HTLC that created half the circuit.
1959c2279
<     /// The total amount of the outgoign HTLC that created the second half of the circuit.
---
>     /// The total amount (in satoshis) of the outgoing HTLC that created the second half of the circuit.
1962c2282
<     /// The total fee that this payment circuit carried.
---
>     /// The total fee (in satoshis) that this payment circuit carried.
1964a2285,2287
>     /// The total fee (in milli-satoshis) that this payment circuit carried.
>     uint64 fee_msat = 8 [json_name = "fee_msat"];
> 
1975a2299,2367
> 
> message ExportChannelBackupRequest {
>     /// The target chanenl point to obtain a back up for.
>     ChannelPoint chan_point = 1;
> }
> 
> message ChannelBackup {
>     /**
>     Identifies the channel that this backup belongs to.
>     */
>     ChannelPoint chan_point = 1 [ json_name = "chan_point" ];
> 
>     /**
>     Is an encrypted single-chan backup. this can be passed to
>     RestoreChannelBackups, or the WalletUnlocker Innit and Unlock methods in
>     order to trigger the recovery protocol.
>     */
>     bytes chan_backup = 2 [ json_name = "chan_backup" ];
> }
> 
> message MultiChanBackup {
>     /**
>     Is the set of all channels that are included in this multi-channel backup.
>     */
>     repeated ChannelPoint chan_points = 1 [ json_name = "chan_points" ];
> 
>     /**
>     A single encrypted blob containing all the static channel backups of the
>     channel listed above. This can be stored as a single file or blob, and
>     safely be replaced with any prior/future versions.
>     */
>     bytes multi_chan_backup = 2 [ json_name = "multi_chan_backup" ];
> }
> 
> message ChanBackupExportRequest {}
> message ChanBackupSnapshot  {
>     /**
>     The set of new channels that have been added since the last channel backup
>     snapshot was requested.
>     */
>     ChannelBackups single_chan_backups = 1 [ json_name = "single_chan_backups" ];
> 
>     /**
>     A multi-channel backup that covers all open channels currently known to
>     lnd.
>     */
>     MultiChanBackup multi_chan_backup  = 2 [ json_name = "multi_chan_backup" ];
> }
> 
> message ChannelBackups {
>     /**
>     A set of single-chan static channel backups.
>     */
>     repeated ChannelBackup chan_backups = 1 [ json_name = "chan_backups" ];
> }
> 
> message RestoreChanBackupRequest {
>     oneof backup {
>         ChannelBackups chan_backups = 1 [ json_name = "chan_backups" ];
> 
>         bytes multi_chan_backup = 2 [ json_name = "multi_chan_backup" ];
>     }
> }
> message RestoreBackupResponse {}
> 
> message ChannelBackupSubscription {}
> 
> message VerifyChanBackupResponse {
> }
