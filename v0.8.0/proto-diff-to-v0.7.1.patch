392c392
<     /** lncli: `subscribechannelevents`
---
>     /**
432a433,441
>     /**
>     ChannelAcceptor dispatches a bi-directional streaming RPC in which
>     OpenChannel requests are sent to the client and the client responds with
>     a boolean that tells LND whether or not to accept the channel. This allows
>     node operators to specify their own criteria for accepting inbound channels
>     through a single persistent connection.
>     */
>     rpc ChannelAcceptor (stream ChannelAcceptResponse) returns (stream ChannelAcceptRequest);
> 
882,883c891,893
<     An optional maximum total time lock for the route. If zero, there is no
<     maximum enforced.
---
>     An optional maximum total time lock for the route. This should not exceed
>     lnd's `--max-cltv-expiry` setting. If zero, then the value of
>     `--max-cltv-expiry` is enforced.
885a896,902
> 
>     /** 
>     An optional field that can be used to pass an arbitrary set of TLV records
>     to a peer which understands the new records. This can be used to pass
>     application specific data during the payment attempt.
>     */
>     map<uint64, bytes> dest_tlv = 11;
907a925,976
> message ChannelAcceptRequest {
>     /// The pubkey of the node that wishes to open an inbound channel.
>     bytes node_pubkey = 1;
> 
>     /// The hash of the genesis block that the proposed channel resides in.
>     bytes chain_hash = 2;
> 
>     /// The pending channel id.
>     bytes pending_chan_id = 3;
> 
>     /// The funding amount in satoshis that initiator wishes to use in the channel.
>     uint64 funding_amt = 4;
> 
>     /// The push amount of the proposed channel in millisatoshis.
>     uint64 push_amt = 5;
> 
>     /// The dust limit of the initiator's commitment tx.
>     uint64 dust_limit = 6;
> 
>     /// The maximum amount of coins in millisatoshis that can be pending in this channel.
>     uint64 max_value_in_flight = 7;
> 
>     /// The minimum amount of satoshis the initiator requires us to have at all times.
>     uint64 channel_reserve = 8;
> 
>     /// The smallest HTLC in millisatoshis that the initiator will accept.
>     uint64 min_htlc = 9;
> 
>     /// The initial fee rate that the initiator suggests for both commitment transactions.
>     uint64 fee_per_kw = 10;
> 
>     /**
>     The number of blocks to use for the relative time lock in the pay-to-self output
>     of both commitment transactions.
>     */
>     uint32 csv_delay = 11;
> 
>     /// The total number of incoming HTLC's that the initiator will accept.
>     uint32 max_accepted_htlcs = 12;
> 
>     /// A bit-field which the initiator uses to specify proposed channel behavior.
>     uint32 channel_flags = 13;
> }
> 
> message ChannelAcceptResponse {
>     /// Whether or not the client accepts the channel.
>     bool accept = 1;
> 
>     /// The pending channel id to which this response applies.
>     bytes pending_chan_id = 2;
> }
> 
1171a1241,1248
> 
>     /**
>     If true, then this channel uses the modern commitment format where the key
>     in the output of the remote party does not change each state. This makes
>     back up and recovery easier as when the channel is closed, the funds go
>     directly to that key. 
>     */
>     bool static_remote_key = 22 [json_name = "static_remote_key"];
1345a1423,1425
> 
>     // Whether we consider ourselves synced with the public channel graph.
>     bool synced_to_graph = 18 [json_name = "synced_to_graph"];
1645c1725
<     A list of edges to ignore during path finding.
---
>     Deprecated. A list of edges to ignore during path finding.
1647c1727
<     repeated EdgeLocator ignored_edges = 7;
---
>     repeated EdgeLocator ignored_edges = 7 [deprecated = true];
1659a1740,1759
> 
>     /**
>     A list of directed node pairs that will be ignored during path finding.
>     */
>     repeated NodePair ignored_pairs = 10;
> 
>     /** 
>     An optional maximum total time lock for the route. If the source is empty or
>     ourselves, this should not exceed lnd's `--max-cltv-expiry` setting. If
>     zero, then the value of `--max-cltv-expiry` is used as the limit.
>     */
>     uint32 cltv_limit = 11;
> }
> 
> message NodePair {
>     /// The sending node of the pair.
>     bytes from = 1;
> 
>     /// The receiving node of the pair.
>     bytes to = 2;
1675a1776,1779
>     /**
>     The route that results from the path finding operation. This is still a
>     repeated field to retain backwards compatibility.
>     */
1676a1781,1786
> 
>     /**
>     The success probability of the returned route based on the current mission
>     control state. [EXPERIMENTAL]
>     */
>     double success_prob = 2 [json_name = "success_prob"];
1697a1808,1813
> 
>     /** 
>     If set to true, then this hop will be encoded using the new variable length
>     TLV format.
>     */
>     bool tlv_payload = 9 [json_name = "tlv_payload"];
2074a2191,2226
> 
>     /// List of HTLCs paying to this invoice [EXPERIMENTAL].
>     repeated InvoiceHTLC htlcs = 22 [json_name = "htlcs"];
> }
> 
> enum InvoiceHTLCState {
>     ACCEPTED = 0;
>     SETTLED = 1;
>     CANCELED = 2;
> }
> 
> /// Details of an HTLC that paid to an invoice
> message InvoiceHTLC {
>     /// Short channel id over which the htlc was received.
>     uint64 chan_id = 1 [json_name = "chan_id"];
> 
>     /// Index identifying the htlc on the channel.
>     uint64 htlc_index = 2 [json_name = "htlc_index"];
> 
>     /// The amount of the htlc in msat.
>     uint64 amt_msat = 3 [json_name = "amt_msat"];
> 
>     /// Block height at which this htlc was accepted.
>     int32 accept_height = 4 [json_name = "accept_height"];
> 
>     /// Time at which this htlc was accepted.
>     int64 accept_time = 5 [json_name = "accept_time"];
> 
>     /// Time at which this htlc was settled or canceled.
>     int64 resolve_time = 6 [json_name = "resolve_time"];
>     
>     /// Block height at which this htlc expires.
>     int32 expiry_height = 7 [json_name = "expiry_height"];
> 
>     /// Current state the htlc is in.
>     InvoiceHTLCState state = 8 [json_name = "state"];
2306a2459,2461
> 
>     /// If set, the maximum HTLC size in milli-satoshis. If unset, the maximum HTLC will be unchanged.
>     uint64 max_htlc_msat = 6 [json_name = "max_htlc_msat"];
