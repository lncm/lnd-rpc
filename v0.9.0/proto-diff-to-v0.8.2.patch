97c97,98
<     to encrypt the generated aezeed cipher seed.
---
>     to encrypt the generated aezeed cipher seed. When using REST, this field
>     must be encoded as base64.
103a105
>     When using REST, this field must be encoded as base64.
128c130,131
<     password is required to unlock the daemon.
---
>     password is required to unlock the daemon. When using REST, this field
>     must be encoded as base64.
141c144,145
<     to encrypt the generated aezeed cipher seed.
---
>     to encrypt the generated aezeed cipher seed. When using REST, this field
>     must be encoded as base64.
171c175
<     function properly.
---
>     function properly. When using REST, this field must be encoded as base64.
199c203
<     daemon.
---
>     daemon. When using REST, this field must be encoded as base64.
205c209
<     daemon.
---
>     daemon. When using REST, this field must be encoded as base64.
357a362,368
>     /**
>     SubscribePeerEvents creates a uni-directional stream from the server to
>     the client in which any events relevant to the state of peers are sent
>     over. Events include peers going online and offline.
>     */
>     rpc SubscribePeerEvents (PeerEventSubscription) returns (stream PeerEvent);
> 
429c440,443
<     lax block confirmation target is used.
---
>     lax block confirmation target is used. Each OpenStatusUpdate will return
>     the pending channel ID of the in-progress channel. Depending on the
>     arguments specified in the OpenChannelRequest, this pending channel ID can
>     then be used to manually progress the channel funding flow.
433a448,459
>     FundingStateStep is an advanced funding related call that allows the caller
>     to either execute some preparatory steps for a funding workflow, or
>     manually progress a funding workflow. The primary way a funding flow is
>     identified is via its pending channel ID. As an example, this method can be
>     used to specify that we're expecting a funding flow for a particular
>     pending channel ID, for which we need to use specific parameters.
>     Alternatively, this can be used to interactively drive PSBT signing for
>     funding for partially complete funding transactions.
>     */
>     rpc FundingStateStep(FundingTransitionMsg) returns (FundingStateStepResp);
> 
>     /**
553c579
<     invoices with an add_index greater than the specified value.  If the
---
>     invoices with an add_index greater than the specified value. If the
555c581
<     invoices with a settle_index greater than the specified value.  One or both
---
>     invoices with a settle_index greater than the specified value. One or both
598c624
<     vertexes themselves.  As this is a directed graph, the edges also contain
---
>     vertexes themselves. As this is a directed graph, the edges also contain
706c732
<     As a result each message can only contain 50k entries.  Each response has
---
>     As a result each message can only contain 50k entries. Each response has
779a806,817
> 
>     /** lncli: `bakemacaroon`
>     BakeMacaroon allows the creation of a new macaroon with custom read and
>     write permissions. No first-party caveats are added since this can be done
>     offline.
>     */
>     rpc BakeMacaroon(BakeMacaroonRequest) returns (BakeMacaroonResponse) {
>         option (google.api.http) = {
>             post: "/v1/macaroon"
>             body: "*"
>         };
>     };
839c877,881
<         /// The fee limit expressed as a fixed amount of satoshis.
---
>         /**
>         The fee limit expressed as a fixed amount of satoshis.
> 
>         The fields fixed and fixed_msat are mutually exclusive.
>         */
841a884,890
>         /**
>         The fee limit expressed as a fixed amount of millisatoshis.
> 
>         The fields fixed and fixed_msat are mutually exclusive.
>         */
>         int64 fixed_msat = 3;
> 
848c897,900
<     /// The identity pubkey of the payment recipient
---
>     /**
>     The identity pubkey of the payment recipient. When using REST, this field
>     must be encoded as base64.
>     */
851,852c903,907
<     /// The hex-encoded identity pubkey of the payment recipient
<     string dest_string = 2;
---
>     /**
>     The hex-encoded identity pubkey of the payment recipient. Deprecated now
>     that the REST gateway supports base64 encoding of bytes fields.
>     */
>     string dest_string = 2 [deprecated = true];
854c909,913
<     /// Number of satoshis to send.
---
>     /**
>     The amount to send expressed in satoshis.
> 
>     The fields amt and amt_msat are mutually exclusive.
>     */
857c916,926
<     /// The hash to use within the payment's HTLC
---
>     /**
>     The amount to send expressed in millisatoshis.
> 
>     The fields amt and amt_msat are mutually exclusive.
>     */
>     int64 amt_msat = 12;
> 
>     /**
>     The hash to use within the payment's HTLC. When using REST, this field
>     must be encoded as base64.
>     */
860,861c929,933
<     /// The hex-encoded hash to use within the payment's HTLC
<     string payment_hash_string = 5;
---
>     /**
>     The hex-encoded hash to use within the payment's HTLC. Deprecated now
>     that the REST gateway supports base64 encoding of bytes fields.
>     */
>     string payment_hash_string = 5 [deprecated = true];
864c936
<     A bare-bones invoice for a payment within the Lightning Network.  With the
---
>     A bare-bones invoice for a payment within the Lightning Network. With the
888c960,965
<     uint64 outgoing_chan_id = 9;
---
>     uint64 outgoing_chan_id = 9 [jstype = JS_STRING];
> 
>     /**
>     The pubkey of the last hop of the route. If empty, any hop may be used.
>     */
>     bytes last_hop_pubkey = 13;
900c977,979
<     application specific data during the payment attempt.
---
>     application specific data during the payment attempt. Record types are
>     required to be in the custom range >= 65536. When using REST, the values
>     must be encoded as base64.
902c981,993
<     map<uint64, bytes> dest_tlv = 11;
---
>     map<uint64, bytes> dest_custom_records = 11;
> 
>     /// If set, circular payments to self are permitted.
>     bool allow_self_payment = 14;
> 
>     /**
>     Features assumed to be supported by the final node. All transitive feature
>     depdencies must also be set properly. For a given feature bit pair, either
>     optional or remote may be set, but not both. If this field is nil or empty,
>     the router will try to load destination features from the graph as a
>     fallback.
>     */
>     repeated FeatureBit dest_features = 15;
913c1004,1007
<     /// The payment hash to use for the HTLC.
---
>     /**
>     The payment hash to use for the HTLC. When using REST, this field must be
>     encoded as base64.
>     */
916,917c1010,1014
<     /// An optional hex-encoded payment hash to be used for the HTLC.
<     string payment_hash_string = 2;
---
>     /**
>     An optional hex-encoded payment hash to be used for the HTLC. Deprecated now
>     that the REST gateway supports base64 encoding of bytes fields.
>     */
>     string payment_hash_string = 2 [deprecated = true];
979c1076,1079
<         /// Txid of the funding transaction
---
>         /**
>         Txid of the funding transaction. When using REST, this field must be
>         encoded as base64.
>         */
982c1082,1085
<         /// Hex-encoded string representing the funding transaction
---
>         /**
>         Hex-encoded string representing the byte-reversed hash of the funding
>         transaction.
>         */
1100c1203,1206
<     /// The message to be signed
---
>     /**
>     The message to be signed. When using REST, this field must be encoded as
>     base64.
>     */
1109c1215,1218
<     /// The message over which the signature is to be verified
---
>     /**
>     The message over which the signature is to be verified. When using REST,
>     this field must be encoded as base64.
>     */
1128c1237
<      * peer.  Otherwise, the call will be synchronous. */
---
>      * peer. Otherwise, the call will be synchronous. */
1167c1276
<     uint64 chan_id = 4 [json_name = "chan_id"];
---
>     uint64 chan_id = 4 [json_name = "chan_id", jstype = JS_STRING];
1248a1358,1379
> 
>     /**
>     The number of seconds that the channel has been monitored by the channel
>     scoring system. Scores are currently not persisted, so this value may be
>     less than the lifetime of the channel [EXPERIMENTAL].
>     */
>     int64 lifetime = 23 [json_name = "lifetime"];
> 
>     /**
>     The number of seconds that the remote peer has been observed as being online
>     by the channel scoring system over the lifetime of the channel [EXPERIMENTAL].
>     */
>     int64 uptime = 24 [json_name = "uptime"];
> 
>     /**
>     Close address is the address that we will enforce payout to on cooperative
>     close if the channel was opened utilizing option upfront shutdown. This
>     value can be set on channel open by setting close_address in an open channel
>     request. If this value is not set, you can still choose a payout address by
>     cooperatively closing with the delivery_address field set.
>     */
>     string close_address = 25 [json_name ="close_address"];
1268c1399
<     uint64 chan_id = 2 [json_name = "chan_id"];
---
>     uint64 chan_id = 2 [json_name = "chan_id", jstype = JS_STRING];
1360a1492,1494
> 
>     /// Features advertised by the remote peer in their init message.
>     map<uint32, Feature> features = 11 [json_name = "features"];
1369a1504,1518
> message PeerEventSubscription {
> }
> 
> message PeerEvent {
>     /// The identity pubkey of the peer.
>     string pub_key = 1 [json_name = "pub_key"];
> 
>     enum EventType {
>         PEER_ONLINE = 0;
>         PEER_OFFLINE = 1;
>     }
> 
>     EventType type = 2 [ json_name = "type" ];
> }
> 
1373a1523,1525
>     /// The version of the LND software that the node is running.
>     string version = 14 [ json_name = "version" ];
> 
1379a1532,1534
>     /// The color of the current node in hex code format
>     string color = 17 [json_name = "color"];
> 
1385a1541,1543
>     /// Number of inactive channels
>     uint32 num_inactive_channels = 15 [json_name = "num_inactive_channels"];
> 
1394a1553,1555
>     /// Timestamp of the block best known to the wallet
>     int64 best_header_timestamp = 13 [ json_name = "best_header_timestamp" ];
> 
1397a1559,1561
>     // Whether we consider ourselves synced with the public channel graph.
>     bool synced_to_graph = 18 [json_name = "synced_to_graph"];
> 
1406,1417d1569
<     /// The URIs of the current node.
<     repeated string uris = 12 [json_name = "uris"];
< 
<     /// Timestamp of the block best known to the wallet
<     int64 best_header_timestamp = 13 [ json_name = "best_header_timestamp" ];
< 
<     /// The version of the LND software that the node is running.
<     string version = 14 [ json_name = "version" ];
< 
<     /// Number of inactive channels
<     uint32 num_inactive_channels = 15 [json_name = "num_inactive_channels"];
< 
1421,1422c1573,1574
<     /// The color of the current node in hex code format
<     string color = 17 [json_name = "color"];
---
>     /// The URIs of the current node.
>     repeated string uris = 12 [json_name = "uris"];
1424,1425c1576,1580
<     // Whether we consider ourselves synced with the public channel graph.
<     bool synced_to_graph = 18 [json_name = "synced_to_graph"];
---
>     /*
>     Features that our node has advertised in our init message, node
>     announcements and invoices.
>     */
>     map<uint32, Feature> features = 19 [json_name = "features"];
1468a1624,1631
> 
>     /*
>     An optional address to send funds to in the case of a cooperative close.
>     If the channel was opened with an upfront shutdown script and this field
>     is set, the request to close will fail because the channel must pay out
>     to the upfront shutdown addresss.
>     */
>     string delivery_address = 5 [json_name = "delivery_address"];
1484c1647,1650
<     /// The pubkey of the node to open a channel with
---
>     /**
>     The pubkey of the node to open a channel with. When using REST, this field
>     must be encoded as base64.
>     */
1487,1488c1653,1657
<     /// The hex encoded pubkey of the node to open a channel with
<     string node_pubkey_string = 3 [json_name = "node_pubkey_string"];
---
>     /**
>     The hex encoded pubkey of the node to open a channel with. Deprecated now
>     that the REST gateway supports base64 encoding of bytes fields.
>     */
>     string node_pubkey_string = 3 [json_name = "node_pubkey_string", deprecated = true];
1515a1685,1705
> 
>     /*
>     Close address is an optional address which specifies the address to which
>     funds should be paid out to upon cooperative close. This field may only be
>     set if the peer supports the option upfront feature bit (call listpeers
>     to check). The remote peer will only accept cooperative closes to this
>     address if it is set.
> 
>     Note: If this value is set on channel creation, you will *not* be able to
>     cooperatively close out to a different address.
>     */
>     string close_address = 13 [json_name = "close_address"];
> 
>     /**
>     Funding shims are an optional argument that allow the caller to intercept
>     certain funding functionality. For example, a shim can be provided to use a
>     particular key for the commitment key (ideally cold) rather than use one
>     that is generated by the wallet as normal, or signal that signing will be
>     carried out in an interactive manner (PSBT based).
>     */
>     FundingShim funding_shim = 14 [json_name = "funding_shim"];
1520a1711,1767
>    }
> 
>     /**
>     The pending channel ID of the created channel. This value may be used to
>     further the funding flow manually via the FundingStateStep method.
>     */
>     bytes pending_chan_id = 4 [json_name = "pending_chan_id"];
> }
> 
> message KeyLocator {
>     /// The family of key being identified.
>     int32 key_family = 1;
> 
>     /// The precise index of the key being identified.
>     int32 key_index = 2;
> }
> 
> message KeyDescriptor {
>      /**
>      The raw bytes of the key being identified. 
>      */
>      bytes raw_key_bytes = 1;
> 
>      /** 
>      The key locator that identifies which key to use for signing. 
>      */
>      KeyLocator key_loc = 2;
> }
> 
> message ChanPointShim {
>     /**
>     The size of the pre-crafted output to be used as the channel point for this
>     channel funding.
>     */
>     int64 amt = 1;
> 
>     /// The target channel point to refrence in created commitment transactions.
>     ChannelPoint chan_point = 2;
> 
>     /// Our local key to use when creating the multi-sig output.
>     KeyDescriptor local_key = 3;
> 
>     /// The key of the remote party to use when creating the multi-sig output.
>     bytes remote_key = 4;
> 
>     /**
>     If non-zero, then this will be used as the pending channel ID on the wire
>     protocol to initate the funding request. This is an optional field, and
>     should only be set if the responder is already expecting a specific pending
>     channel ID.
>     */
>     bytes pending_chan_id = 5;
> }
> 
> message FundingShim {
>     oneof shim {
>         ChanPointShim chan_point_shim = 1;
1523a1771,1792
> message FundingShimCancel {
>     /// The pending channel ID of the channel to cancel the funding shim for.
>     bytes pending_chan_id = 1;
> }
> 
> message FundingTransitionMsg {
>     oneof trigger {
>         /**
>         The funding shim to regsiter. This should be used before any
>         channel funding has began by the remote party, as it is intended as a
>         prepatory step for the full channel funding.
>         */
>         FundingShim shim_register = 1;
> 
>         /// Used to cancel an existing registered funding shim.
>         FundingShimCancel shim_cancel = 2;
>     }
> }
> 
> message FundingStateStepResp {
> }
> 
1703c1972,1976
<     /// The amount to send expressed in satoshis
---
>     /**
>     The amount to send expressed in satoshis.
> 
>     The fields amt and amt_msat are mutually exclusive.
>     */
1705a1979,1985
>     /**
>     The amount to send expressed in millisatoshis.
> 
>     The fields amt and amt_msat are mutually exclusive.
>     */
>     int64 amt_msat = 12;
> 
1708c1988,1994
<     /// An optional CLTV delta from the current height that should be used for the timelock of the final hop
---
>     /**
>     An optional CLTV delta from the current height that should be used for the
>     timelock of the final hop. Note that unlike SendPayment, QueryRoutes does
>     not add any additional block padding on top of final_ctlv_delta. This
>     padding of a few blocks needs to be added manually or otherwise failures may
>     happen when a block comes in while the payment is in flight.
>     */
1720c2006,2007
<     A list of nodes to ignore during path finding.
---
>     A list of nodes to ignore during path finding. When using REST, these fields
>     must be encoded as base64.
1751a2039,2073
> 
>     /** 
>     An optional field that can be used to pass an arbitrary set of TLV records
>     to a peer which understands the new records. This can be used to pass
>     application specific data during the payment attempt. If the destination
>     does not support the specified recrods, and error will be returned.
>     Record types are required to be in the custom range >= 65536. When using
>     REST, the values must be encoded as base64.
>     */
>     map<uint64, bytes> dest_custom_records = 13;
> 
>     /**
>     The channel id of the channel that must be taken to the first hop. If zero,
>     any channel may be used.
>     */
>     uint64 outgoing_chan_id = 14 [jstype = JS_STRING];
> 
>     /**
>     The pubkey of the last hop of the route. If empty, any hop may be used.
>     */
>     bytes last_hop_pubkey = 15;
> 
>     /**
>     Optional route hints to reach the destination through private channels.
>     */
>     repeated lnrpc.RouteHint route_hints = 16;
> 
>     /**
>     Features assumed to be supported by the final node. All transitive feature
>     depdencies must also be set properly. For a given feature bit pair, either
>     optional or remote may be set, but not both. If this field is nil or empty,
>     the router will try to load destination features from the graph as a
>     fallback.
>     */
>     repeated lnrpc.FeatureBit dest_features = 17;
1755c2077,2080
<     /// The sending node of the pair.
---
>     /**
>     The sending node of the pair. When using REST, this field must be encoded as
>     base64.
>     */
1758c2083,2086
<     /// The receiving node of the pair.
---
>     /**
>     The receiving node of the pair. When using REST, this field must be encoded
>     as base64.
>     */
1764c2092
<     uint64 channel_id = 1;
---
>     uint64 channel_id = 1 [jstype = JS_STRING];
1795c2123
<     uint64 chan_id = 1 [json_name = "chan_id"];
---
>     uint64 chan_id = 1 [json_name = "chan_id", jstype = JS_STRING];
1811c2139,2140
<     TLV format.
---
>     TLV format. Note that if any custom tlv_records below are specified, then
>     this field MUST be set to true for them to be encoded properly.
1813a2143,2175
> 
>     /**
>     An optional TLV record tha singals the use of an MPP payment. If present,
>     the receiver will enforce that that the same mpp_record is included in the
>     final hop payload of all non-zero payments in the HTLC set. If empty, a
>     regular single-shot payment is or was attempted.
>     */
>     MPPRecord mpp_record = 10 [json_name = "mpp_record"];
> 
>     /**
>     An optional set of key-value TLV records. This is useful within the context
>     of the SendToRoute call as it allows callers to specify arbitrary K-V pairs
>     to drop off at each hop within the onion.
>     */
>     map<uint64, bytes> custom_records = 11 [json_name = "custom_records"];
> }
> 
> message MPPRecord {
>     /**
>     A unique, random identifier used to authenticate the sender as the intended
>     payer of a multi-path payment. The payment_addr must be the same for all
>     subpayments, and match the payment_addr provided in the receiver's invoice.
>     The same payment_addr must be used on all subpayments.
>     */
>     bytes payment_addr = 11 [json_name = "payment_addr"];
> 
>     /**
>     The total amount in milli-satoshis being sent as part of a larger multi-path
>     payment. The caller is responsible for ensuring subpayments to the same node
>     and payment_hash sum exactly to total_amt_msat. The same
>     total_amt_msat must be used on all subpayments.
>     */
>     int64 total_amt_msat = 10 [json_name = "total_amt_msat"];
1826c2188
<     The cumulative (final) time lock across the entire route.  This is the CLTV
---
>     The cumulative (final) time lock across the entire route. This is the CLTV
1834c2196
<     The sum of the fees paid at each hop within the final route.  In the case
---
>     The sum of the fees paid at each hop within the final route. In the case
1904a2267
>     map<uint32, Feature> features = 6 [ json_name = "features" ];
1936c2299
<     uint64 channel_id = 1 [json_name = "channel_id"];
---
>     uint64 channel_id = 1 [json_name = "channel_id", jstype = JS_STRING];
1974c2337
<     uint64 chan_id = 1;
---
>     uint64 chan_id = 1 [jstype = JS_STRING];
2023c2386
<     uint64 chan_id = 1;
---
>     uint64 chan_id = 1 [jstype = JS_STRING];
2040c2403
<     uint64 chan_id = 1;
---
>     uint64 chan_id = 1 [jstype = JS_STRING];
2051c2414
<     uint64 chan_id = 2 [json_name = "chan_id"];
---
>     uint64 chan_id = 2 [json_name = "chan_id", jstype = JS_STRING];
2083,2086c2446
<     /** Deprecated. An optional cryptographic receipt of payment which is not
<     implemented.
<     */
<     bytes receipt = 2 [json_name = "receipt", deprecated = true];
---
>     reserved 2;
2090c2450,2451
<     HTLC payable to this preimage
---
>     HTLC payable to this preimage. When using REST, this field must be encoded
>     as base64.
2094c2455,2458
<     /// The hash of the preimage
---
>     /**
>     The hash of the preimage. When using REST, this field must be encoded as
>     base64.
>     */
2097c2461,2465
<     /// The value of this invoice in satoshis
---
>     /**
>     The value of this invoice in satoshis
> 
>     The fields value and value_msat are mutually exclusive.
>     */
2099a2468,2474
>     /**
>     The value of this invoice in millisatoshis
> 
>     The fields value and value_msat are mutually exclusive.
>     */
>     int64 value_msat = 23 [json_name = "value_msat"];
> 
2110c2485
<     A bare-bones invoice for a payment within the Lightning Network.  With the
---
>     A bare-bones invoice for a payment within the Lightning Network. With the
2119c2494,2495
<     of an encoded payment request.
---
>     of an encoded payment request. When using REST, this field must be encoded
>     as base64.
2193a2570,2578
> 
>     /// List of features advertised on the invoice.
>     map<uint32, Feature> features = 24 [json_name = "features"];
>     
>     /**
>     Indicates if this invoice was a spontaneous payment that arrived via keysend
>     [EXPERIMENTAL].
>     */
>     bool is_keysend = 25 [json_name = "is_keysend"];
2205c2590
<     uint64 chan_id = 1 [json_name = "chan_id"];
---
>     uint64 chan_id = 1 [json_name = "chan_id", jstype = JS_STRING];
2226a2612,2617
> 
>     /// Custom tlv records.
>     map<uint64, bytes> custom_records = 9 [json_name = "custom_records"];
> 
>     /// The total amount of the mpp payment in msat.
>     uint64 mpp_total_amt_msat = 10 [json_name = "mpp_total_amt_msat"];
2233c2624
<     A bare-bones invoice for a payment within the Lightning Network.  With the
---
>     A bare-bones invoice for a payment within the Lightning Network. With the
2250a2642,2643
>     Deprecated now that the REST gateway supports base64 encoding of bytes
>     fields.
2252c2645
<     string r_hash_str = 1 [json_name = "r_hash_str"];
---
>     string r_hash_str = 1 [json_name = "r_hash_str", deprecated = true];
2254c2647,2650
<     /// The payment hash of the invoice to be looked up.
---
>     /**
>     The payment hash of the invoice to be looked up. When using REST, this field
>     must be encoded as base64.
>     */
2259c2655,2658
<     /// If set, only unsettled invoices will be returned in the response.
---
>     /**
>     If set, only invoices that are not settled and not canceled will be returned
>     in the response.
>     */
2323,2324c2722,2723
<     /// The date of this payment
<     int64 creation_date = 3 [json_name = "creation_date"];
---
>     /// Deprecated, use creation_time_ns
>     int64 creation_date = 3 [json_name = "creation_date", deprecated = true];
2326,2327c2725,2726
<     /// The path this payment took
<     repeated string path = 4 [ json_name = "path" ];
---
>     /// The path this payment took.
>     repeated string path = 4 [json_name = "path", deprecated = true];
2358a2758,2786
> 
>     /// The time in UNIX nanoseconds at which the payment was created.
>     int64 creation_time_ns = 13 [json_name = "creation_time_ns"];
> 
>     /// The HTLCs made in attempt to settle the payment [EXPERIMENTAL].
>     repeated HTLCAttempt htlcs = 14 [json_name = "htlcs"];
> }
> 
> message HTLCAttempt {
>         enum HTLCStatus {
>                 IN_FLIGHT = 0;
>                 SUCCEEDED = 1;
>                 FAILED = 2;
>         }
> 
>         /// The status of the HTLC.
>         HTLCStatus status = 1 [json_name = "status"];
> 
>         /// The route taken by this HTLC.
>         Route route = 2 [json_name = "route"];
> 
>         /// The time in UNIX nanoseconds at which this HTLC was sent.
>         int64 attempt_time_ns = 3 [json_name = "attempt_time_ns"];
> 
>         /**
>         The time in UNIX nanoseconds at which this HTLC was settled or failed.
>         This value will not be set if the HTLC is still IN_FLIGHT.
>         */
>         int64 resolve_time_ns = 4 [json_name = "resolve_time_ns"];
2411a2840,2868
>     bytes payment_addr = 11 [json_name = "payment_addr"];
>     int64 num_msat = 12 [json_name = "num_msat"];
>     map<uint32, Feature> features = 13 [json_name = "features"];
> }
> 
> enum FeatureBit {
>         DATALOSS_PROTECT_REQ = 0;
>         DATALOSS_PROTECT_OPT = 1;
>         INITIAL_ROUING_SYNC = 3;
>         UPFRONT_SHUTDOWN_SCRIPT_REQ = 4;
>         UPFRONT_SHUTDOWN_SCRIPT_OPT = 5;
>         GOSSIP_QUERIES_REQ = 6;
>         GOSSIP_QUERIES_OPT = 7;
>         TLV_ONION_REQ = 8;
>         TLV_ONION_OPT = 9;
>         EXT_GOSSIP_QUERIES_REQ = 10;
>         EXT_GOSSIP_QUERIES_OPT = 11;
>         STATIC_REMOTE_KEY_REQ = 12;
>         STATIC_REMOTE_KEY_OPT = 13;
>         PAYMENT_ADDR_REQ = 14;
>         PAYMENT_ADDR_OPT = 15;
>         MPP_REQ = 16;
>         MPP_OPT = 17;
> }
> 
> message Feature {
>         string name = 2 [json_name = "name"];
>         bool is_required = 3 [json_name = "is_required"];
>         bool is_known = 4 [json_name = "is_known"];
2461a2919,2924
> 
>     /// The minimum HTLC size in milli-satoshis. Only applied if min_htlc_msat_specified is true.
>     uint64 min_htlc_msat = 7 [json_name = "min_htlc_msat"];
> 
>     /// If true, min_htlc_msat is applied.
>     bool min_htlc_msat_specified = 8 [json_name = "set_min_htlc_msat"];
2484c2947
<     uint64 chan_id_in = 2 [json_name = "chan_id_in"];
---
>     uint64 chan_id_in = 2 [json_name = "chan_id_in", jstype = JS_STRING];
2487c2950
<     uint64 chan_id_out = 4 [json_name = "chan_id_out"];
---
>     uint64 chan_id_out = 4 [json_name = "chan_id_out", jstype = JS_STRING];
2500a2964,2970
>     /// The total amount (in milli-satoshis) of the incoming HTLC that created half the circuit.
>     uint64 amt_in_msat = 9 [json_name = "amt_in_msat"];
> 
>     /// The total amount (in milli-satoshis) of the outgoing HTLC that created the second half of the circuit.
>     uint64 amt_out_msat = 10 [json_name = "amt_out_msat"];
> 
> 
2527c2997,2998
<     order to trigger the recovery protocol.
---
>     order to trigger the recovery protocol. When using REST, this field must be
>     encoded as base64.
2541c3012,3013
<     safely be replaced with any prior/future versions.
---
>     safely be replaced with any prior/future versions. When using REST, this
>     field must be encoded as base64.
2569a3042,3044
>         /**
>         The channels to restore as a list of channel/backup pairs.
>         */
2571a3047,3050
>         /**
>         The channels to restore in the packed multi backup format. When using
>         REST, this field must be encoded as base64.
>         */
2580a3060,3075
> 
> message MacaroonPermission {
>     /// The entity a permission grants access to.
>     string entity = 1 [json_name = "entity"];
> 
>     /// The action that is granted.
>     string action = 2 [json_name = "action"];
> }
> message BakeMacaroonRequest {
>     /// The list of permissions the new macaroon should grant.
>     repeated MacaroonPermission permissions = 1 [json_name = "permissions"];
> }
> message BakeMacaroonResponse {
>     /// The hex encoded macaroon, serialized in binary format.
>     string macaroon = 1 [json_name = "macaroon"];
> }
